COP3530
Homework 6

Instructor: Dr. K. Weiss


Preparation/Delivery Instructions:

   1. For each homework create a folder with your last name.

   2. For this homework:
                For each problem (task) j  create a separate subdirectory lastname/j, where you 
		place all files belonging to problem j (e.g. directory lastname/3 stores the files and answers for 
		problem 3 for this homework).

   3. To get full credit:
		- your work, design, and code must follow the problem requirements and description EXACTLY.
		- your designs and code must follow the course guidelines and must compile without 
		warnings and work correctly, as required in the problem description. 

	*** I also have to repeat this: it is academic misconduct to submit work that is not yours.  ***

   4. After you solve all problems for a homework, zip the entire homework directory to a file lastname.zip.
      All text files (.txt) must be Windows compatible (watch out if you are using linux).

   5. Submit the file lastname.zip on Canvas before the deadline. 

----------------
Other general advice that will help you do well in this class. And build better code, too.

    * Ask your instructor if you have any questions about the homework.

    * Consult the textbook for examples.

    * Do exactly what the problem asks you to do. There is no extra credit for unnecessary work.

    * Follow the instructions in the problem text or get points deducted. 

    * Do not change names for the classes and methods specified, if they are given.

    * Do not change the method signature, where specified.

    * Design/code your classes for general use. Assume there are other programmers who will use your code.

    * Avoid unnecessary side effects.

    * Check for errors.

    * Follow coding conventions; class names start with capitals, methods and variables start with lowercase, etc. 


==============================================================================================================
Task 1
Draw all the possible Binary Search Trees that contain four nodes with values 1, 2, 3, and 4. 
Ensure that each tree meets the criteria for a Binary Search Tree.

Files to submit:
An image of your answer. Can be powerpoint file or jpeg image.

Task 2
You are given a BST class template which supports a number of BST functions. You are to add BST 
functions as follows. For the functions provided in the BST class, you can assume these functions 
are correctly implemented. That is, a constructed Binary Search tree meets all the Binary Search 
Tree criteria. You can assume there are no duplicate entries in the Binary Search Tree. You can use 
any function that is provided in the BST class. You cannot change any function defintions. There are 
five functions to code in the BST.h file which are found at the bottom of the file. 
There are 19 testcases to pass. The results of the testcases are captured in the BST-results.txt 
file located in the working directory. The four files provided will initially compile together. 
The functions to implement are as follows:

1) countNodesAux(subtreeRoot) private member function. The function
countNodes() is public member function of class BST that returns the total number of nodes 
in the tree. If the tree is empty, it returns zero. countNodes() calls
unsigned countNodesAux(subtreeRoot). There is no extra coding needed for countNodes().
The countNodesAux(subtreeRoot) private member function is a recursive function that
needs to be coded. This function returns the total number of nodes in the tree.

2) indexSearch(item) is a non-recursive public member function of class BST. 
This function returns the node index of a particular node in the tree. If the tree is
empty OR the item is not in the tree, then a -1 is returned. It is highly recommended that you
use the code for the search() algorithm already provided by the BST class as the basis for this 
implementation. The node index is the mapping of the nodes to an array starting with the root node 
at index 0. The second level of the tree contains index numbers 1 through 2 moving from left to right, 
the 3rd level of the tree contains index numbers 3 through 6, and so on. Therefore, if there 
were 3 nodes in the tree all on the extreme right side, the index of the last node is 6.

3) copyAux(BinNodePointer treeToCopy). 
The copy constructor is implemented by calling the recursive function
copyAux(BinNodePointer treeToCopy).
copyAux is a recursive private member function that needs to be implemented.
The implementation will copy the nodes from treeToCopy to the current object at myRoot
in the exact tree order. The new tree that is created will need to have nodes allocated 
from memory. You can assume that treeToCopy is a Binary Search
Tree. Hint: review the six traversal patterns to find the appropriate one for this function.

4) destructAux(BinNodePointer subtreeRoot)
The destructor is implemented by calling the recursive function
destructAux(BinNodePointer subtreeRoot).
destructAux is a recursive private member function that needs to be implemented.
All nodes of the tree need to be deallocated.
Hint: review the six traversal patterns to find the appropriate one for this function.

5) The assignment operator needs to be implemented and needs to use the copyAux() and destructAux() 
to accomplish its functionality. Fully implement the assignment operator using opyAux() and destructAux().

Files to provided:
BST.h
BST-Main.cpp
MyFileIO.cpp
MyFileIO.h

Files to submit:
BST.h
BST-results.txt